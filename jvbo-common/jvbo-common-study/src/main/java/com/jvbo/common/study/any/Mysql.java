/*
 * Mysql.java 2018年3月25日
 * Copyright (c) 2015-2018, Jv Bo (programmer_jv_bo@163.com).
 */
package com.jvbo.common.study.any;

public class Mysql {
    
    /**
     * 索引几大原则:
     * 1. 最左前缀匹配原则;
     * 2. =和in可以乱序;
     * 3. 尽量选择区分度高的列作为索引;
     * 4. 索引列不能参与计算;
     * 5. 尽量的扩展索引,不要新建索引;
     * 
     * 事务四种隔离机制:
     * 1. 未提交读:允许脏读,也就是可能读取到其他会话中未提交事务修改的数据;
     * 2. 提交读:只能读取到已提交的数据,oracle等多种数据库默认都是该级别(不重复读);
     * 3. 可重复读:可重复读;在同一个事务内的查询都是事务开始时刻一致的,InnoDB默认级别,消除了不可重复读,但还是可能出现幻读;
     * 5. 串行读:完全串行化,每次读都需要获得表级共享锁,读写相互都会阻塞
     * 隔离级别                                          脏读(dirty read)   不可重复读(nonrepeatable read)   幻读(phantom read)
     * 未提交读(read uncommitted)   可能                              可能                                                        可能
     * 已提交读(read committed)     不可能                           可能                                                        可能
     * 可重复读(repeatable read)    不可能                           不可能                                                     可能
     * 可串行化(serializable)       不可能                           不可能                                                     不可能
     * 
     *
     * 
     * 锁分类:
     * 1. 根据锁的类型:共享锁,排它锁,意向共享锁,意向排它锁;
     * 2. 根据锁的粒度:行锁,表锁;
     * 
     * mysql中InnoDB的锁:行锁(索引记录锁),gap锁(索引记录间隙锁),next-key锁(记录锁加上记录之前gap锁的组合),
     * 说明:
     * 1. 对于更新操作(读不上锁),只有走索引才可能上行锁;否则会对聚簇索引的每一行上锁,实际等于对表上锁;
     * 2. 若多个物理记录对应同一个索引,若同时访问,也会出现锁冲突;
     * 3. 当表有多个索引时,不同事务可以用不同的索引锁住不同的行,另外innodb会同时用行锁对数据记录(聚簇索引)加锁;
     * 4. MVCC并发控制机制下,任何操作都不会阻塞读操作,读操作也不会阻塞任何操作,只因为读不上锁;
     */
    
    
    public static void main(String[] args) {
        System.out.println(Integer.valueOf(129) == 129);
    }
}
