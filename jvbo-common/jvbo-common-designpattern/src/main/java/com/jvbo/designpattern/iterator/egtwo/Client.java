/*
 * Client.java 2017年11月10日
 * Copyright (c) 2015-2017, Jv Bo (programmer_jv_bo@163.com).
 */
package com.jvbo.designpattern.iterator.egtwo;

/**
 * 迭代子模式-白箱聚集与外禀迭代子-客户端类
 * @ClassName: Client 
 * @Description: 迭代子模式又叫游标(Cursor)模式,是对象的行为模式,
 * 迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象(internal representation)
 * @author jvbo
 * @date 2017年11月10日
 */
public class Client {
	/**
	 * 黑箱聚集与内禀迭代子
	 * 
	 * 黑箱实现方案:
	 * 如果一个聚集的接口没有提供修改聚集元素的方法,这样的接口就是所谓的窄接口;
	 * 聚集对象为迭代子对象提供一个宽接口,而为其他对象提供一个窄接口;
	 * 换言之,聚集对象的内部结构应当对迭代子对象适当公开,以便迭代子对象能够对聚集对象有足够的了解,从而可以进行迭代操作;
	 * 但是,聚集对象应当避免向其他的对象提供这些方法,因为其他对象应当经过迭代子对象进行这些工作,而不是直接操控聚集对象;
	 * java中,实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类,这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构;
	 * 这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做黑箱实现方案;
	 * 
	 * 内禀迭代子:
	 * 由于迭代子是聚集的内部类,迭代子可以自由访问聚集的元素,所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑;
	 * 由于迭代子是在聚集的结构之内定义的,因此这样的迭代子又叫做内禀迭代子(Intrinsic Iterator)
	 */
	
	/**
	 * 首先创建了一个聚集类实例,然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象;
	 * 在得到迭代子的实例后,客户端开始迭代过程,打印出所有的聚集元素;
	 */
	public void operation(){
		Object[] objArray = {"One","Two","Three","Four","Five","Six"};
		//创建聚合对象
        Aggregate agg = new ConcreteAggregate(objArray);
        //循环输出聚合对象中的值
        Iterator it = agg.createIterator();
        while(!it.isDone()){
            System.out.println(it.currentItem());
            it.next();
        }
	}
	
	public static void main(String[] args) {
		Client client = new Client();
		client.operation();
	}
}

/**
 * 1.主动迭代子和被动迭代子
 * a.主动迭代子和被动迭代子又称作外部迭代子和内部迭代子;
 * b.所谓主动(外部)迭代子,指的是由客户端来控制迭代下一个元素的步骤,客户端会明显调用迭代子的next()等迭代方法,在遍历过程中向前进行;
 * c.所谓被动(内部)迭代子,指的是由迭代子自己来控制迭代下一个元素的步骤;
 * 因此,如果想要在迭代的过程中完成工作的话,客户端就需要把操作传递给迭代子,迭代子在迭代的时候会在每个元素上执行这个操作,类似于java的回调机制;
 * d.总体来说外部迭代器比内部迭代器要灵活一些,因此我们常见的实现多属于主动迭代子;
 * 
 * 2.静态迭代子和动态迭代子
 * a.静态迭代子由聚集对象创建,并持有聚集对象的一份快照(snapshot),在产生后这个快照的内容就不再变化;
 * 客户端可以继续修改原聚集的内容,但是迭代子对象不会反映出聚集的新变化;静态迭代子的好处是它的安全性和简易性,换言之,静态迭代子易于实现,
 * 不容易出现错误;但是由于静态迭代子将原聚集复制了一份,因此它的短处是对时间和内存资源的消耗;
 * b.动态迭代子则与静态迭代子完全相反,在迭代子被产生之后,迭代子保持着对聚集元素的引用,因此,任何对原聚集内容的修改都会在迭代子对象上反映出来;
 * 完整的动态迭代子不容易实现,但是简化的动态迭代子并不难实现;
 * 
 * 3.Fail-Fast
 * 如果一个算法开始之后,它的运算环境发生变化,使得算法无法进行必需的调整时,这个算法就应当立即发出故障信号;这就是Fail Fast的含义;
 * 如果聚集对象的元素在一个动态迭代子的迭代过程中发生变化时,迭代过程会受到影响而变得不能自恰;这时候,迭代子就应当立即抛出一个异常;
 * 这种迭代子就是实现了Fail Fast功能的迭代子;
 * 
 * 4.迭代子模式优点
 * a.迭代子模式简化了聚集的接口;迭代子具备了一个遍历接口,这样聚集的接口就不必具备遍历接口;
 * b.每一个聚集对象都可以有一个或多个迭代子对象,每一个迭代子的迭代状态可以是彼此独立的;因此,一个聚集对象可以同时有几个迭代在进行之中;
 * c.由于遍历算法被封装在迭代子角色里面,因此迭代的算法可以独立于聚集角色变化;
 */
